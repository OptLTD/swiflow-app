package action

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"
)

func TestPathListFiles_Handle(t *testing.T) {
	tempDir := t.TempDir()

	// 创建测试文件和目录
	testFile := filepath.Join(tempDir, "test.txt")
	if err := os.WriteFile(testFile, []byte("test content"), 0644); err != nil {
		t.Fatalf("创建测试文件失败: %v", err)
	}

	testSubDir := filepath.Join(tempDir, "subdir")
	if err := os.Mkdir(testSubDir, 0755); err != nil {
		t.Fatalf("创建测试目录失败: %v", err)
	}

	pathListFiles := &PathListFiles{
		Path: ".", // 使用相对路径，表示当前目录
	}

	super := &SuperAction{
		Payload: &Payload{
			UUID: "test-uuid",
			Home: tempDir,
			Time: time.Now(),
		},
	}

	// 执行前 Result 应该为 nil
	if pathListFiles.Result != nil {
		t.Errorf("执行前 Result 应该为 nil")
	}

	result := pathListFiles.Handle(super)

	// 执行后 Result 应该被初始化
	if pathListFiles.Result == nil {
		t.Errorf("执行后 Result 应该被初始化")
	}

	// 验证返回的 Result 和 PathListFiles.Result 是同一个实例
	if result != pathListFiles.Result {
		t.Errorf("返回的 Result 和 PathListFiles.Result 应该是同一个实例")
	}

	// 验证结果包含 markdown 表格格式
	if result.Result == "" {
		t.Errorf("结果不应该为空")
		return
	}

	// 添加调试信息
	t.Logf("实际结果: %s", result.Result)

	if !strings.Contains(result.Result, "| mode |") {
		t.Errorf("结果应该包含 markdown 表格头")
	}
	if !strings.Contains(result.Result, "test\\.txt") {
		t.Errorf("结果应该包含测试文件名")
	}
	if !strings.Contains(result.Result, "subdir") {
		t.Errorf("结果应该包含测试目录名")
	}
}

func TestPathListFiles_HandleEmptyDir(t *testing.T) {
	tempDir := t.TempDir()

	pathListFiles := &PathListFiles{
		Path: ".", // 使用相对路径，表示当前目录
	}

	super := &SuperAction{
		Payload: &Payload{
			UUID: "test-uuid",
			Home: tempDir,
			Time: time.Now(),
		},
	}

	result := pathListFiles.Handle(super)

	// 验证空目录的结果
	if result.Result == "" {
		t.Errorf("结果不应该为空")
		return
	}

	if !strings.Contains(result.Result, "| mode |") {
		t.Errorf("结果应该包含 markdown 表格头")
	}
	// 空目录应该只有表头，没有数据行
	lines := strings.Split(result.Result, "\n")
	if len(lines) < 3 {
		t.Errorf("结果应该至少包含表头、分隔行和空行")
	}
}

func TestFileGetContent_Handle(t *testing.T) {
	tempDir := t.TempDir()
	testContent := "这是测试文件内容\n包含多行文本"
	testFile := filepath.Join(tempDir, "test.txt")

	if err := os.WriteFile(testFile, []byte(testContent), 0644); err != nil {
		t.Fatalf("创建测试文件失败: %v", err)
	}

	fileGetContent := &FileGetContent{
		Path: "test.txt", // 相对路径
	}

	super := &SuperAction{
		Payload: &Payload{
			UUID: "test-uuid",
			Home: tempDir,
			Time: time.Now(),
		},
	}

	// 执行前 Result 应该为 nil
	if fileGetContent.Result != nil {
		t.Errorf("执行前 Result 应该为 nil")
	}

	result := fileGetContent.Handle(super)

	// 执行后 Result 应该被初始化
	if fileGetContent.Result == nil {
		t.Errorf("执行后 Result 应该被初始化")
	}

	// 验证返回的 Result 和 FileGetContent.Result 是同一个实例
	if result != fileGetContent.Result {
		t.Errorf("返回的 Result 和 FileGetContent.Result 应该是同一个实例")
	}

	// 验证文件内容
	if result.Result == "" {
		t.Errorf("结果不应该为空")
		return
	}

	if result.Result != testContent {
		t.Errorf("文件内容不匹配，期望: %q, 实际: %q", testContent, result.Result)
	}
}

func TestFileGetContent_HandleAbsolutePath(t *testing.T) {
	tempDir := t.TempDir()
	testContent := "绝对路径测试内容"
	testFile := filepath.Join(tempDir, "absolute.txt")

	if err := os.WriteFile(testFile, []byte(testContent), 0644); err != nil {
		t.Fatalf("创建测试文件失败: %v", err)
	}

	fileGetContent := &FileGetContent{
		Path: testFile, // 绝对路径
	}

	super := &SuperAction{
		Payload: &Payload{
			UUID: "test-uuid",
			Home: tempDir,
			Time: time.Now(),
		},
	}

	result := fileGetContent.Handle(super)

	// 验证文件内容
	if result.Result == "" {
		t.Errorf("结果不应该为空")
		return
	}

	if result.Result != testContent {
		t.Errorf("文件内容不匹配，期望: %q, 实际: %q", testContent, result.Result)
	}
}

func TestFileGetContent_HandleNonExistentFile(t *testing.T) {
	tempDir := t.TempDir()

	fileGetContent := &FileGetContent{
		Path: "nonexistent.txt",
	}

	super := &SuperAction{
		Payload: &Payload{
			UUID: "test-uuid",
			Home: tempDir,
			Time: time.Now(),
		},
	}

	result := fileGetContent.Handle(super)

	// 验证错误处理
	if result.ErrMsg == nil {
		t.Errorf("应该返回错误信息")
	}
}

func TestFilePutContent_Handle(t *testing.T) {
	tempDir := t.TempDir()
	testContent := "这是要写入的测试内容\n包含换行符"

	filePutContent := &FilePutContent{
		Path: "test_write.txt",
		Data: testContent,
	}

	super := &SuperAction{
		Payload: &Payload{
			UUID: "test-uuid",
			Home: tempDir,
			Time: time.Now(),
		},
	}

	// 执行前 Result 应该为 nil
	if filePutContent.Result != nil {
		t.Errorf("执行前 Result 应该为 nil")
	}

	result := filePutContent.Handle(super)

	// 执行后 Result 应该被初始化
	if filePutContent.Result == nil {
		t.Errorf("执行后 Result 应该被初始化")
	}

	// 验证返回的 Result 和 FilePutContent.Result 是同一个实例
	if result != filePutContent.Result {
		t.Errorf("返回的 Result 和 FilePutContent.Result 应该是同一个实例")
	}

	// 验证写入成功
	if result.Result == "" {
		t.Errorf("结果不应该为空")
		return
	}

	if result.Result != "success" {
		t.Errorf("期望返回 'success'，实际: %q", result.Result)
	}

	// 验证文件确实被创建并包含正确内容
	filePath := filepath.Join(tempDir, "test_write.txt")
	if _, err := os.Stat(filePath); os.IsNotExist(err) {
		t.Errorf("文件应该被创建")
		return
	}

	content, err := os.ReadFile(filePath)
	if err != nil {
		t.Errorf("读取创建的文件失败: %v", err)
		return
	}

	if string(content) != testContent {
		t.Errorf("文件内容不匹配，期望: %q, 实际: %q", testContent, string(content))
	}
}

func TestFilePutContent_HandleWithSubDir(t *testing.T) {
	tempDir := t.TempDir()
	testContent := "子目录测试内容"

	filePutContent := &FilePutContent{
		Path: "subdir/test.txt",
		Data: testContent,
	}

	super := &SuperAction{
		Payload: &Payload{
			UUID: "test-uuid",
			Home: tempDir,
			Time: time.Now(),
		},
	}

	result := filePutContent.Handle(super)

	// 验证写入成功
	if result.Result == "" {
		t.Errorf("结果不应该为空")
		return
	}

	if result.Result != "success" {
		t.Errorf("期望返回 'success'，实际: %q", result.Result)
	}

	// 验证子目录和文件被创建
	filePath := filepath.Join(tempDir, "subdir", "test.txt")
	if _, err := os.Stat(filePath); os.IsNotExist(err) {
		t.Errorf("文件应该被创建在子目录中")
		return
	}

	content, err := os.ReadFile(filePath)
	if err != nil {
		t.Errorf("读取创建的文件失败: %v", err)
		return
	}

	if string(content) != testContent {
		t.Errorf("文件内容不匹配，期望: %q, 实际: %q", testContent, string(content))
	}
}

func TestFileReplaceText_Handle(t *testing.T) {
	tempDir := t.TempDir()
	originalContent := "这是原始内容\n包含一些文本\n需要被替换的部分\n结束"
	testFile := filepath.Join(tempDir, "replace_test.txt")

	if err := os.WriteFile(testFile, []byte(originalContent), 0644); err != nil {
		t.Fatalf("创建测试文件失败: %v", err)
	}

	diff := `<<<<<<< SEARCH
需要被替换的部分
=======
这是替换后的新内容
>>>>>>> REPLACE`

	fileReplaceText := &FileReplaceText{
		Path: "replace_test.txt",
		Diff: diff,
	}

	super := &SuperAction{
		Payload: &Payload{
			UUID: "test-uuid",
			Home: tempDir,
			Time: time.Now(),
		},
	}

	// 执行前 Result 应该为 nil
	if fileReplaceText.Result != nil {
		t.Errorf("执行前 Result 应该为 nil")
	}

	result := fileReplaceText.Handle(super)

	// 执行后 Result 应该被初始化
	if fileReplaceText.Result == nil {
		t.Errorf("执行后 Result 应该被初始化")
	}

	// 验证返回的 Result 和 FileReplaceText.Result 是同一个实例
	if result != fileReplaceText.Result {
		t.Errorf("返回的 Result 和 FileReplaceText.Result 应该是同一个实例")
	}

	// 验证替换成功
	if result.Result == "" {
		t.Errorf("结果不应该为空")
		return
	}

	if result.Result != "success" {
		t.Errorf("期望返回 'success'，实际: %q", result.Result)
	}

	// 验证文件内容确实被替换
	content, err := os.ReadFile(testFile)
	if err != nil {
		t.Errorf("读取替换后的文件失败: %v", err)
		return
	}

	expectedContent := "这是原始内容\n包含一些文本\n这是替换后的新内容\n结束"
	if string(content) != expectedContent {
		t.Errorf("文件内容不匹配，期望: %q, 实际: %q", expectedContent, string(content))
	}
}

func TestFileReplaceText_HandleMultipleReplacements(t *testing.T) {
	tempDir := t.TempDir()
	originalContent := "第一行\n第二行\n第三行\n第四行"
	testFile := filepath.Join(tempDir, "multi_replace.txt")

	if err := os.WriteFile(testFile, []byte(originalContent), 0644); err != nil {
		t.Fatalf("创建测试文件失败: %v", err)
	}

	diff := `<<<<<<< SEARCH
第一行
=======
第一行（已修改）
>>>>>>> REPLACE
<<<<<<< SEARCH
第三行
=======
第三行（已修改）
>>>>>>> REPLACE`

	fileReplaceText := &FileReplaceText{
		Path: "multi_replace.txt",
		Diff: diff,
	}

	super := &SuperAction{
		Payload: &Payload{
			UUID: "test-uuid",
			Home: tempDir,
			Time: time.Now(),
		},
	}

	result := fileReplaceText.Handle(super)

	// 验证替换成功
	if result.Result == "" {
		t.Errorf("结果不应该为空")
		return
	}

	if result.Result != "success" {
		t.Errorf("期望返回 'success'，实际: %q", result.Result)
	}

	// 验证文件内容确实被替换
	content, err := os.ReadFile(testFile)
	if err != nil {
		t.Errorf("读取替换后的文件失败: %v", err)
		return
	}

	expectedContent := "第一行（已修改）\n第二行\n第三行（已修改）\n第四行"
	if string(content) != expectedContent {
		t.Errorf("文件内容不匹配，期望: %q, 实际: %q", expectedContent, string(content))
	}
}

func TestFileReplaceText_HandleInvalidDiff(t *testing.T) {
	tempDir := t.TempDir()
	originalContent := "原始内容"
	testFile := filepath.Join(tempDir, "invalid_diff.txt")

	if err := os.WriteFile(testFile, []byte(originalContent), 0644); err != nil {
		t.Fatalf("创建测试文件失败: %v", err)
	}

	// 无效的 diff 格式
	invalidDiff := `<<<<<<< SEARCH
原始内容
=======
新内容`

	fileReplaceText := &FileReplaceText{
		Path: "invalid_diff.txt",
		Diff: invalidDiff,
	}

	super := &SuperAction{
		Payload: &Payload{
			UUID: "test-uuid",
			Home: tempDir,
			Time: time.Now(),
		},
	}

	result := fileReplaceText.Handle(super)

	// 验证错误处理
	if result.ErrMsg == nil {
		t.Errorf("应该返回错误信息")
	}

	// 验证文件内容没有被修改
	content, err := os.ReadFile(testFile)
	if err != nil {
		t.Errorf("读取文件失败: %v", err)
		return
	}

	if string(content) != originalContent {
		t.Errorf("文件内容不应该被修改，期望: %q, 实际: %q", originalContent, string(content))
	}
}

func TestPathListFiles_ParseXML(t *testing.T) {
	tests := []struct {
		name     string
		xmlData  string
		expected *PathListFiles
	}{
		{
			name: "基本路径解析",
			xmlData: `<path-list-files>
				<path>/home/user</path>
			</path-list-files>`,
			expected: &PathListFiles{
				Path: "/home/user",
			},
		},
		{
			name: "相对路径解析",
			xmlData: `<path-list-files>
				<path>./documents</path>
			</path-list-files>`,
			expected: &PathListFiles{
				Path: "./documents",
			},
		},
		{
			name: "带结果的路径解析",
			xmlData: `<path-list-files>
				<path>/tmp</path>
				<result>| mode | size | name |</result>
			</path-list-files>`,
			expected: &PathListFiles{
				Path: "/tmp",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// 使用 action.Parse 解析 XML
			super := Parse(tt.xmlData)

			// 验证解析结果
			if len(super.UseTools) == 0 {
				t.Errorf("期望解析出工具，但没有解析出任何工具")
				return
			}

			// 查找 PathListFiles 类型的工具
			var pathListFiles *PathListFiles
			for _, tool := range super.UseTools {
				if plf, ok := tool.(*PathListFiles); ok {
					pathListFiles = plf
					break
				}
			}

			if pathListFiles == nil {
				t.Errorf("期望解析出 PathListFiles，但没有找到")
				return
			}

			// 验证路径内容
			if pathListFiles.Path != tt.expected.Path {
				t.Errorf("路径不匹配，期望: %q, 实际: %q", tt.expected.Path, pathListFiles.Path)
			}

			// 验证 XML 标签
			if pathListFiles.XMLName.Local != "path-list-files" {
				t.Errorf("XML 标签不匹配，期望: path-list-files, 实际: %s", pathListFiles.XMLName.Local)
			}
		})
	}
}

func TestFileGetContent_ParseXML(t *testing.T) {
	tests := []struct {
		name     string
		xmlData  string
		expected *FileGetContent
	}{
		{
			name: "基本文件路径解析",
			xmlData: `<file-get-content>
				<path>test.txt</path>
			</file-get-content>`,
			expected: &FileGetContent{
				Path: "test.txt",
			},
		},
		{
			name: "绝对路径解析",
			xmlData: `<file-get-content>
				<path>/home/user/document.txt</path>
			</file-get-content>`,
			expected: &FileGetContent{
				Path: "/home/user/document.txt",
			},
		},
		{
			name: "带结果的文件解析",
			xmlData: `<file-get-content>
				<path>config.json</path>
				<result>{"key": "value"}</result>
			</file-get-content>`,
			expected: &FileGetContent{
				Path: "config.json",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			super := Parse(tt.xmlData)

			if len(super.UseTools) == 0 {
				t.Errorf("期望解析出工具，但没有解析出任何工具")
				return
			}

			var fileGetContent *FileGetContent
			for _, tool := range super.UseTools {
				if fgc, ok := tool.(*FileGetContent); ok {
					fileGetContent = fgc
					break
				}
			}

			if fileGetContent == nil {
				t.Errorf("期望解析出 FileGetContent，但没有找到")
				return
			}

			if fileGetContent.Path != tt.expected.Path {
				t.Errorf("路径不匹配，期望: %q, 实际: %q", tt.expected.Path, fileGetContent.Path)
			}

			if fileGetContent.XMLName.Local != "file-get-content" {
				t.Errorf("XML 标签不匹配，期望: file-get-content, 实际: %s", fileGetContent.XMLName.Local)
			}
		})
	}
}

func TestFilePutContent_ParseXML(t *testing.T) {
	tests := []struct {
		name     string
		xmlData  string
		expected *FilePutContent
	}{
		{
			name: "基本文件写入解析",
			xmlData: `<file-put-content>
				<path>output.txt</path>
				<data>Hello World</data>
			</file-put-content>`,
			expected: &FilePutContent{
				Path: "output.txt",
				Data: "Hello World",
			},
		},
		{
			name: "多行内容解析",
			xmlData: `<file-put-content>
				<path>multi.txt</path>
				<data>第一行
第二行
第三行</data>
			</file-put-content>`,
			expected: &FilePutContent{
				Path: "multi.txt",
				Data: "第一行\n第二行\n第三行",
			},
		},
		{
			name: "带结果的文件写入解析",
			xmlData: `<file-put-content>
				<path>success.txt</path>
				<data>写入成功</data>
				<result>success</result>
			</file-put-content>`,
			expected: &FilePutContent{
				Path: "success.txt",
				Data: "写入成功",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			super := Parse(tt.xmlData)

			if len(super.UseTools) == 0 {
				t.Errorf("期望解析出工具，但没有解析出任何工具")
				return
			}

			var filePutContent *FilePutContent
			for _, tool := range super.UseTools {
				if fpc, ok := tool.(*FilePutContent); ok {
					filePutContent = fpc
					break
				}
			}

			if filePutContent == nil {
				t.Errorf("期望解析出 FilePutContent，但没有找到")
				return
			}

			if filePutContent.Path != tt.expected.Path {
				t.Errorf("路径不匹配，期望: %q, 实际: %q", tt.expected.Path, filePutContent.Path)
			}

			if filePutContent.Data != tt.expected.Data {
				t.Errorf("内容不匹配，期望: %q, 实际: %q", tt.expected.Data, filePutContent.Data)
			}

			if filePutContent.XMLName.Local != "file-put-content" {
				t.Errorf("XML 标签不匹配，期望: file-put-content, 实际: %s", filePutContent.XMLName.Local)
			}
		})
	}
}

func TestFileReplaceText_ParseXML(t *testing.T) {
	tests := []struct {
		name     string
		xmlData  string
		expected *FileReplaceText
	}{
		{
			name: "基本文本替换解析",
			xmlData: `<file-replace-text>
				<path>update.txt</path>
				<diff><<<<<<< SEARCH
old text
=======
new text
>>>>>>> REPLACE</diff>
			</file-replace-text>`,
			expected: &FileReplaceText{
				Path: "update.txt",
				Diff: "<<<<<<< SEARCH\nold text\n=======\nnew text\n>>>>>>> REPLACE",
			},
		},
		{
			name: "复杂替换解析",
			xmlData: `<file-replace-text>
				<path>complex.txt</path>
				<diff><<<<<<< SEARCH
需要替换的内容
=======
替换后的内容
>>>>>>> REPLACE
<<<<<<< SEARCH
另一个需要替换的内容
=======
另一个替换后的内容
>>>>>>> REPLACE</diff>
			</file-replace-text>`,
			expected: &FileReplaceText{
				Path: "complex.txt",
				Diff: "<<<<<<< SEARCH\n需要替换的内容\n=======\n替换后的内容\n>>>>>>> REPLACE\n<<<<<<< SEARCH\n另一个需要替换的内容\n=======\n另一个替换后的内容\n>>>>>>> REPLACE",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			super := Parse(tt.xmlData)

			if len(super.UseTools) == 0 {
				t.Errorf("期望解析出工具，但没有解析出任何工具")
				return
			}

			var fileReplaceText *FileReplaceText
			for _, tool := range super.UseTools {
				if frt, ok := tool.(*FileReplaceText); ok {
					fileReplaceText = frt
					break
				}
			}

			if fileReplaceText == nil {
				t.Errorf("期望解析出 FileReplaceText，但没有找到")
				return
			}

			if fileReplaceText.Path != tt.expected.Path {
				t.Errorf("路径不匹配，期望: %q, 实际: %q", tt.expected.Path, fileReplaceText.Path)
			}

			if fileReplaceText.Diff != tt.expected.Diff {
				t.Errorf("diff 不匹配，期望: %q, 实际: %q", tt.expected.Diff, fileReplaceText.Diff)
			}

			if fileReplaceText.XMLName.Local != "file-replace-text" {
				t.Errorf("XML 标签不匹配，期望: file-replace-text, 实际: %s", fileReplaceText.XMLName.Local)
			}
		})
	}
}

func TestFileSystem_ParseComplexXML(t *testing.T) {
	// 测试复杂的 XML 结构，包含多个文件系统操作
	complexXML := `<path-list-files>
		<path>/tmp</path>
	</path-list-files>
	<thinking>列出目录内容</thinking>
	<file-get-content>
		<path>config.txt</path>
	</file-get-content>
	<file-put-content>
		<path>output.txt</path>
		<data>写入的内容</data>
	</file-put-content>`

	super := Parse(complexXML)

	// 验证解析出了多个工具
	if len(super.UseTools) < 3 {
		t.Errorf("期望解析出至少3个工具，实际解析出 %d 个", len(super.UseTools))
	}

	// 统计各种文件系统操作的数量
	pathListFilesCount := 0
	fileGetContentCount := 0
	filePutContentCount := 0

	for _, tool := range super.UseTools {
		switch tool.(type) {
		case *PathListFiles:
			pathListFilesCount++
		case *FileGetContent:
			fileGetContentCount++
		case *FilePutContent:
			filePutContentCount++
		}
	}

	if pathListFilesCount != 1 {
		t.Errorf("期望解析出1个 PathListFiles，实际解析出 %d 个", pathListFilesCount)
	}
	if fileGetContentCount != 1 {
		t.Errorf("期望解析出1个 FileGetContent，实际解析出 %d 个", fileGetContentCount)
	}
	if filePutContentCount != 1 {
		t.Errorf("期望解析出1个 FilePutContent，实际解析出 %d 个", filePutContentCount)
	}

	// 验证 thinking 内容
	if super.Thinking != "列出目录内容" {
		t.Errorf("thinking 内容不匹配，期望: 列出目录内容, 实际: %s", super.Thinking)
	}
}
